<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Really Simple Algorithm Solutions</title>
  <style>
    :root {
      --primary: #3b82f6;
      --primary-dark: #2563eb;
      --secondary: #64748b;
      --border: #e2e8f0;
      --background: #f8fafc;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      line-height: 1.6;
      background: var(--background);
      color: #1e293b;
      padding-bottom: 3rem;
    }
    .header {
      background: white;
      padding: 2rem;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }
    .header h1 {
      margin: 0;
      color: var(--primary-dark);
      font-size: 2rem;
    }
    .header p {
      color: var(--secondary);
      margin: 0.5rem 0 0;
    }
    .container {
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    .snippet-container {
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
      overflow: hidden;
    }
    .snippet-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .snippet-header h2 {
      margin: 0;
      color: var(--primary-dark);
      font-size: 1.25rem;
    }
    .explain-button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }
    .explain-button:hover {
      background: var(--primary-dark);
    }
    .problem-statement {
      padding: 1rem;
      background: #fff9e6;
      border-bottom: 1px solid var(--border);
      color: var(--primary-dark);
      font-size: 1rem;
    }
    .explanation {
      display: none;
      padding: 1rem;
      background: #f0f7ff;
      border-bottom: 1px solid var(--border);
      color: var(--secondary);
      font-size: 0.95rem;
    }
    pre {
      margin: 0;
      padding: 1.5rem;
      background: #1e293b;
      color: #e2e8f0;
      overflow-x: auto;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    code {
      white-space: pre;
    }
    .problem-nav {
      position: fixed;
      top: 0;
      right: 0;
      background: white;
      padding: 1rem;
      border-left: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      border-bottom-left-radius: 0.5rem;
      max-height: 100vh;
      overflow-y: auto;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
    }
    .problem-nav h3 {
      margin: 0 0 1rem 0;
      color: var(--primary-dark);
    }
    .problem-nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .problem-nav li {
      margin-bottom: 0.5rem;
    }
    .problem-nav a {
      color: var(--secondary);
      text-decoration: none;
      font-size: 0.9rem;
    }
    .problem-nav a:hover {
      color: var(--primary);
    }
    @media (max-width: 768px) {
      .problem-nav {
        display: none;
      }
      .header h1 {
        font-size: 1.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Really Simple Algorithm Solutions</h1>
    <p>The easiest (even if very inefficient) ways to solve each problem.</p>
  </div>
  <nav class="problem-nav">
    <h3>Problems</h3>
    <ul>
      <li><a href="#fibonacci">Fibonacci</a></li>
      <li><a href="#missing-number">Missing Number</a></li>
      <li><a href="#repetitions">Repetitions</a></li>
      <li><a href="#subsequence">Is Subsequence</a></li>
      <li><a href="#increasing-array">Increasing Array</a></li>
      <li><a href="#sum-two">Sum of Two Values</a></li>
      <li><a href="#permutations">Permutations</a></li>
      <li><a href="#two-knights">Two Knights</a></li>
      <li><a href="#max-subarray">Max Subarray Sum</a></li>
      <li><a href="#knapsack">Fractional Knapsack</a></li>
      <li><a href="#counting-rooms">Counting Rooms</a></li>
      <li><a href="#josephus">Josephus Problem</a></li>
      <li><a href="#tasks">Tasks and Deadlines</a></li>
      <li><a href="#restaurant">Restaurant Customers</a></li>
      <li><a href="#increasing-subseq">Increasing Subsequence</a></li>
      <li><a href="#min-coins">Minimizing Coins</a></li>
      <li><a href="#jump-game">Jump Game II</a></li>
      <li><a href="#grid-paths">Grid Paths</a></li>
      <li><a href="#planets">Planets Queries</a></li>
      <li><a href="#removing-digits">Removing Digits</a></li>
      <li><a href="#knights-tour">Knight's Tour</a></li>
      <li><a href="#labyrinth">Labyrinth</a></li>
    </ul>
  </nav>
  <div class="container">
    <!-- Fibonacci -->
    <div id="fibonacci" class="snippet-container">
      <div class="snippet-header">
        <h2>Compute Fibonacci</h2>
        <button class="explain-button" onclick="toggleExplanation('exp1')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a number n, compute the nth Fibonacci number (where the sequence starts at 0, 1, 1, 2, 3, …).
      </div>
      <div id="exp1" class="explanation">
        <strong>Solution Explanation:</strong> We use a simple loop starting with 0 and 1, then repeatedly add the two previous numbers to get the next Fibonacci number.
      </div>
      <pre><code>// Very simple Fibonacci: add two numbers repeatedly
#include <iostream>
using namespace std;
int main() {
  int n;
  cin >> n;
  if(n == 0) { cout << 0; return 0; }
  int a = 0, b = 1;
  for(int i = 2; i <= n; i++){
    int c = a + b;
    a = b;
    b = c;
  }
  cout << b;
  return 0;
}
</code></pre>
    </div>

    <!-- Missing Number -->
    <div id="missing-number" class="snippet-container">
      <div class="snippet-header">
        <h2>Missing Number</h2>
        <button class="explain-button" onclick="toggleExplanation('exp2')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> You are given n and a list of n-1 numbers from 1 to n. Find the one number that is missing.
      </div>
      <div id="exp2" class="explanation">
        <strong>Solution Explanation:</strong> We check every number from 1 to n by scanning the list to see which number is not present.
      </div>
      <pre><code>// Check every number 1 to n to find the missing one
#include <iostream>
using namespace std;
int main() {
  int n;
  cin >> n;
  int arr[1000];
  for (int i = 0; i < n - 1; i++){
    cin >> arr[i];
  }
  for (int num = 1; num <= n; num++){
    bool found = false;
    for (int i = 0; i < n - 1; i++){
      if(arr[i] == num){
        found = true;
        break;
      }
    }
    if(!found) { cout << num; break; }
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Repetitions -->
    <div id="repetitions" class="snippet-container">
      <div class="snippet-header">
        <h2>Repetitions</h2>
        <button class="explain-button" onclick="toggleExplanation('exp3')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a sentence, identify and print the letters that appear more than once.
      </div>
      <div id="exp3" class="explanation">
        <strong>Solution Explanation:</strong> For each letter in the string, we count its occurrences using nested loops.
      </div>
      <pre><code>
// For each letter, count how many times it shows up
#include <iostream>
#include <cstring>
using namespace std;
int main() {
  char text[1000];
  cin.getline(text, 1000);
  int len = strlen(text);
  for (int i = 0; i < len; i++){
    bool alreadySeen = false;
    for (int j = 0; j < i; j++){
      if(text[j] == text[i]) { alreadySeen = true; break; }
    }
    if(alreadySeen) continue;
    int count = 0;
    for (int k = 0; k < len; k++){
      if(text[i] == text[k]) count++;
    }
    if(count > 1) cout << text[i] << " ";
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Is Subsequence -->
    <div id="subsequence" class="snippet-container">
      <div class="snippet-header">
        <h2>Is Subsequence</h2>
        <button class="explain-button" onclick="toggleExplanation('exp4')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given two strings, check whether the second string appears in the first string in order (not necessarily consecutively).
      </div>
      <div id="exp4" class="explanation">
        <strong>Solution Explanation:</strong> We traverse the first string and try to match each letter of the second string one by one.
      </div>
      <pre><code>
// Check if every letter of t appears in s in order
#include <iostream>
#include <cstring>
using namespace std;
int main() {
  char s[1000], t[1000];
  cin.getline(s, 1000);
  cin.getline(t, 1000);
  int i = 0, j = 0;
  while(s[i] != '\0' && t[j] != '\0'){
    if(s[i] == t[j]) j++;
    i++;
  }
  cout << (t[j]=='\0' ? "Yes" : "No");
  return 0;
}
</code></pre>
    </div>

    <!-- Increasing Array -->
    <div id="increasing-array" class="snippet-container">
      <div class="snippet-header">
        <h2>Increasing Array</h2>
        <button class="explain-button" onclick="toggleExplanation('exp5')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array, make it non-decreasing by increasing elements. Count the total increments needed.
      </div>
      <div id="exp5" class="explanation">
        <strong>Solution Explanation:</strong> For every element that is smaller than its previous element, we add the difference to make it equal.
      </div>
      <pre><code>
// Increase numbers to make the array non-decreasing
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  int moves = 0;
  for(int i = 1; i < n; i++){
    if(arr[i] < arr[i-1]){
      moves += arr[i-1] - arr[i];
      arr[i] = arr[i-1];
    }
  }
  cout << moves;
  return 0;
}
</code></pre>
    </div>

    <!-- Sum of Two Values -->
    <div id="sum-two" class="snippet-container">
      <div class="snippet-header">
        <h2>Sum of Two Values</h2>
        <button class="explain-button" onclick="toggleExplanation('exp6')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a list of numbers and a target value, find two distinct numbers that add up to the target.
      </div>
      <div id="exp6" class="explanation">
        <strong>Solution Explanation:</strong> We try every pair of numbers; when we find a pair whose sum equals the target, we print their indices.
      </div>
      <pre><code>
// Check every pair to see if they add up to target
#include <iostream>
using namespace std;
int main(){
  int n, target;
  cin >> n >> target;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  for(int i = 0; i < n; i++){
    for(int j = i+1; j < n; j++){
      if(arr[i] + arr[j] == target){
        cout << i << " " << j;
        return 0;
      }
    }
  }
  cout << "No solution";
  return 0;
}
</code></pre>
    </div>

    <!-- Permutations -->
    <div id="permutations" class="snippet-container">
      <div class="snippet-header">
        <h2>Permutations</h2>
        <button class="explain-button" onclick="toggleExplanation('exp7')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a word, list all possible arrangements (permutations) of its letters.
      </div>
      <div id="exp7" class="explanation">
        <strong>Solution Explanation:</strong> We use recursion and swap letters to generate every possible ordering of the characters.
      </div>
      <pre><code>
// Print every rearrangement of a word (brute force)
#include <iostream>
#include <cstring>
using namespace std;
void swap(char &a, char &b){
  char temp = a;
  a = b;
  b = temp;
}
void permute(char s[], int l, int r){
  if(l == r)
    cout << s << "\n";
  else {
    for(int i = l; i <= r; i++){
      swap(s[l], s[i]);
      permute(s, l+1, r);
      swap(s[l], s[i]); // backtrack
    }
  }
}
int main(){
  char s[1000];
  cin >> s;
  int n = strlen(s);
  permute(s, 0, n-1);
  return 0;
}
</code></pre>
    </div>

    <!-- Two Knights -->
    <div id="two-knights" class="snippet-container">
      <div class="snippet-header">
        <h2>Two Knights</h2>
        <button class="explain-button" onclick="toggleExplanation('exp8')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> On an n×n chessboard, count how many ways you can place two knights so that they do not attack each other.
      </div>
      <div id="exp8" class="explanation">
        <strong>Solution Explanation:</strong> We check every possible pair of board positions and count it if the two knights do not threaten each other.
      </div>
      <pre><code>
// Count placements for two knights on an n x n board (brute force)
#include <iostream>
#include <cstdlib>
using namespace std;
bool attacks(int x1, int y1, int x2, int y2){
  int dx = abs(x1 - x2), dy = abs(y1 - y2);
  return (dx == 1 && dy == 2) || (dx == 2 && dy == 1);
}
int main(){
  int n;
  cin >> n;
  long long count = 0;
  for(int x1 = 0; x1 < n; x1++){
    for(int y1 = 0; y1 < n; y1++){
      for(int x2 = 0; x2 < n; x2++){
        for(int y2 = 0; y2 < n; y2++){
          if(x1==x2 && y1==y2) continue;
          if(!attacks(x1,y1,x2,y2))
            count++;
        }
      }
    }
  }
  cout << count/2;
  return 0;
}
</code></pre>
    </div>

    <!-- Maximum Subarray Sum -->
    <div id="max-subarray" class="snippet-container">
      <div class="snippet-header">
        <h2>Maximum Subarray Sum</h2>
        <button class="explain-button" onclick="toggleExplanation('exp9')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array, find the maximum sum obtainable by summing a contiguous block of elements.
      </div>
      <div id="exp9" class="explanation">
        <strong>Solution Explanation:</strong> We try every possible subarray using three nested loops and keep track of the highest sum.
      </div>
      <pre><code>
// Try all subarrays and remember the biggest sum
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  int maxSum = arr[0];
  for(int i = 0; i < n; i++){
    for(int j = i; j < n; j++){
      int sum = 0;
      for(int k = i; k <= j; k++){
        sum += arr[k];
      }
      if(sum > maxSum)
        maxSum = sum;
    }
  }
  cout << maxSum;
  return 0;
}
</code></pre>
    </div>

    <!-- Fractional Knapsack -->
    <div id="knapsack" class="snippet-container">
      <div class="snippet-header">
        <h2>Fractional Knapsack</h2>
        <button class="explain-button" onclick="toggleExplanation('exp10')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given items with weights and values and a bag with limited capacity, choose fractions of items to maximize total value.
      </div>
      <div id="exp10" class="explanation">
        <strong>Solution Explanation:</strong> We try fixed fractions (0, 0.1, …, 1) for each item using recursion and update the best total value.
      </div>
      <pre><code>
// Try fractions of each item (using a fixed step) to get best value
#include <iostream>
using namespace std;
double best = 0;
void tryItems(int index, double weight, double value, double capacity, int n, double w[], double v[], double step){
  if(index == n){
    if(weight <= capacity && value > best)
      best = value;
    return;
  }
  for(double frac = 0; frac <= 1.0; frac += step){
    double newWeight = weight + frac * w[index];
    double newValue = value + frac * v[index];
    if(newWeight <= capacity)
      tryItems(index+1, newWeight, newValue, capacity, n, w, v, step);
  }
}
int main(){
  int n;
  double capacity;
  cin >> n >> capacity;
  double w[1000], v[1000];
  for(int i = 0; i < n; i++){
    cin >> w[i] >> v[i];
  }
  double step = 0.1;
  tryItems(0, 0.0, 0.0, capacity, n, w, v, step);
  cout << best;
  return 0;
}
</code></pre>
    </div>

    <!-- Counting Rooms -->
    <div id="counting-rooms" class="snippet-container">
      <div class="snippet-header">
        <h2>Counting Rooms</h2>
        <button class="explain-button" onclick="toggleExplanation('exp11')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a grid representing a map (with '.' as open space and '#' as walls), count the number of connected open areas (rooms).
      </div>
      <div id="exp11" class="explanation">
        <strong>Solution Explanation:</strong> For every unvisited open cell, we use recursion (DFS) to mark the whole room and count it.
      </div>
      <pre><code>
// Count rooms by filling each connected area
#include <iostream>
using namespace std;
int n, m;
char grid[101][101];
void fillRoom(int i, int j){
  if(i < 0 || i >= n || j < 0 || j >= m) return;
  if(grid[i][j] != '.') return;
  grid[i][j] = '#';
  fillRoom(i+1,j);
  fillRoom(i-1,j);
  fillRoom(i,j+1);
  fillRoom(i,j-1);
}
int main(){
  cin >> n >> m;
  for(int i = 0; i < n; i++){
    cin >> grid[i];
  }
  int rooms = 0;
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      if(grid[i][j] == '.'){
        rooms++;
        fillRoom(i,j);
      }
    }
  }
  cout << rooms;
  return 0;
}
</code></pre>
    </div>

    <!-- Josephus Problem -->
    <div id="josephus" class="snippet-container">
      <div class="snippet-header">
        <h2>Josephus Problem</h2>
        <button class="explain-button" onclick="toggleExplanation('exp12')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> In a circle of n people, remove every kth person until only one remains. Output the survivor.
      </div>
      <div id="exp12" class="explanation">
        <strong>Solution Explanation:</strong> We simulate the process by using an array and shifting the elements every time a person is removed.
      </div>
      <pre><code>
// Remove every kth person until one remains
#include <iostream>
using namespace std;
int main(){
  int n, k;
  cin >> n >> k;
  int circle[1000];
  for(int i = 0; i < n; i++){
    circle[i] = i + 1;
  }
  int size = n, index = 0;
  while(size > 1){
    index = (index + k - 1) % size;
    for(int i = index; i < size - 1; i++){
      circle[i] = circle[i+1];
    }
    size--;
  }
  cout << circle[0];
  return 0;
}
</code></pre>
    </div>

    <!-- Tasks and Deadlines -->
    <div id="tasks" class="snippet-container">
      <div class="snippet-header">
        <h2>Tasks and Deadlines</h2>
        <button class="explain-button" onclick="toggleExplanation('exp13')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given tasks with deadlines and profits, determine the order of tasks that maximizes total profit.
      </div>
      <div id="exp13" class="explanation">
        <strong>Solution Explanation:</strong> We try every permutation (order) of tasks using recursion and swapping, then calculate the profit for each order.
      </div>
      <pre><code>
// Try every order (permutation) of tasks to get maximum profit
#include <iostream>
using namespace std;
int n, bestProfit = 0;
int d[10], p[10];
void swap(int &a, int &b){
  int temp = a; a = b; b = temp;
}
void permute(int pos){
  if(pos == n){
    int time = 0, profit = 0;
    for(int i = 0; i < n; i++){
      time++;
      if(time <= d[i])
        profit += p[i];
    }
    if(profit > bestProfit)
      bestProfit = profit;
    return;
  }
  for(int i = pos; i < n; i++){
    swap(d[pos], d[i]);
    swap(p[pos], p[i]);
    permute(pos+1);
    swap(d[pos], d[i]);
    swap(p[pos], p[i]);
  }
}
int main(){
  cin >> n;
  for(int i = 0; i < n; i++){
    cin >> d[i] >> p[i];
  }
  permute(0);
  cout << bestProfit;
  return 0;
}
</code></pre>
    </div>

    <!-- Restaurant Customers -->
    <div id="restaurant" class="snippet-container">
      <div class="snippet-header">
        <h2>Restaurant Customers</h2>
        <button class="explain-button" onclick="toggleExplanation('exp14')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given the arrival and departure times of customers, determine the maximum number of customers present at any one time.
      </div>
      <div id="exp14" class="explanation">
        <strong>Solution Explanation:</strong> We find the minimum start and maximum finish times and check each time unit for the count of customers.
      </div>
      <pre><code>
// Count customers at each time unit to find the maximum number present
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  int start[1000], finish[1000];
  int minT = 1000000000, maxT = 0;
  for(int i = 0; i < n; i++){
    cin >> start[i] >> finish[i];
    if(start[i] < minT) minT = start[i];
    if(finish[i] > maxT) maxT = finish[i];
  }
  int maxCust = 0;
  for(int t = minT; t <= maxT; t++){
    int count = 0;
    for(int i = 0; i < n; i++){
      if(t >= start[i] && t <= finish[i])
        count++;
    }
    if(count > maxCust)
      maxCust = count;
  }
  cout << maxCust;
  return 0;
}
</code></pre>
    </div>

    <!-- Increasing Subsequence -->
    <div id="increasing-subseq" class="snippet-container">
      <div class="snippet-header">
        <h2>Increasing Subsequence</h2>
        <button class="explain-button" onclick="toggleExplanation('exp15')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array, find the length of the longest subsequence where the numbers are in strictly increasing order.
      </div>
      <div id="exp15" class="explanation">
        <strong>Solution Explanation:</strong> We try both including and skipping each number using recursion, keeping track of the longest valid subsequence.
      </div>
      <pre><code>
// Try all ways to pick numbers so they are in increasing order
#include <iostream>
using namespace std;
int best = 0;
void dfs(int i, int last, int count, int n, int arr[]){
  if(i == n){
    if(count > best) best = count;
    return;
  }
  // Skip this number
  dfs(i+1, last, count, n, arr);
  // Include this number if it is larger than the last chosen
  if(arr[i] > last)
    dfs(i+1, arr[i], count+1, n, arr);
}
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  dfs(0, -1000000000, 0, n, arr);
  cout << best;
  return 0;
}
</code></pre>
    </div>

    <!-- Minimizing Coins -->
    <div id="min-coins" class="snippet-container">
      <div class="snippet-header">
        <h2>Minimizing Coins</h2>
        <button class="explain-button" onclick="toggleExplanation('exp16')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given coin denominations and a target amount, find the minimum number of coins needed to make that amount.
      </div>
      <div id="exp16" class="explanation">
        <strong>Solution Explanation:</strong> We try every combination of coins recursively (brute force) and choose the combination with the fewest coins.
      </div>
      <pre><code>
// Try all coin combinations (very brute force)
#include <iostream>
#include <climits>
using namespace std;
int bestCoins = INT_MAX;
void tryCoins(int index, int count, int remaining, int n, int coins[]){
  if(remaining == 0){
    if(count < bestCoins)
      bestCoins = count;
    return;
  }
  if(index >= n) return;
  for(int i = 0; i * coins[index] <= remaining; i++){
    tryCoins(index+1, count+i, remaining - i * coins[index], n, coins);
  }
}
int main(){
  int n, amount;
  cin >> n >> amount;
  int coins[1000];
  for(int i = 0; i < n; i++){
    cin >> coins[i];
  }
  tryCoins(0, 0, amount, n, coins);
  cout << (bestCoins == INT_MAX ? -1 : bestCoins);
  return 0;
}
</code></pre>
    </div>

    <!-- Jump Game II -->
    <div id="jump-game" class="snippet-container">
      <div class="snippet-header">
        <h2>Jump Game II</h2>
        <button class="explain-button" onclick="toggleExplanation('exp17')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array where each element is the maximum jump length from that position, determine the minimum number of jumps needed to reach the end.
      </div>
      <div id="exp17" class="explanation">
        <strong>Solution Explanation:</strong> We use recursion to try every possible jump from the current index until the end is reached and keep the minimum jump count.
      </div>
      <pre><code>
// Try every jump (brute force) to reach the end of the array
#include <iostream>
#include <climits>
using namespace std;
int minJumps = INT_MAX;
void jump(int index, int count, int n, int arr[]){
  if(index >= n - 1){
    if(count < minJumps)
      minJumps = count;
    return;
  }
  for(int j = 1; j <= arr[index]; j++){
    jump(index+j, count+1, n, arr);
  }
}
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  jump(0, 0, n, arr);
  cout << (minJumps == INT_MAX ? -1 : minJumps);
  return 0;
}
</code></pre>
    </div>

    <!-- Grid Paths -->
    <div id="grid-paths" class="snippet-container">
      <div class="snippet-header">
        <h2>Grid Paths</h2>
        <button class="explain-button" onclick="toggleExplanation('exp18')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Count the number of ways to travel from the top left to the bottom right of a grid if you can only move right or down.
      </div>
      <div id="exp18" class="explanation">
        <strong>Solution Explanation:</strong> We use a simple recursive function to add the number of paths from moving right and down.
      </div>
      <pre><code>
// Count paths in a grid (only right and down moves)
#include <iostream>
using namespace std;
int countPaths(int i, int j, int rows, int cols){
  if(i == rows - 1 && j == cols - 1)
    return 1;
  if(i >= rows || j >= cols)
    return 0;
  return countPaths(i+1, j, rows, cols) + countPaths(i, j+1, rows, cols);
}
int main(){
  int rows, cols;
  cin >> rows >> cols;
  cout << countPaths(0, 0, rows, cols);
  return 0;
}
</code></pre>
    </div>

    <!-- Planets Queries -->
    <div id="planets" class="snippet-container">
      <div class="snippet-header">
        <h2>Planets Queries</h2>
        <button class="explain-button" onclick="toggleExplanation('exp19')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a set of connections between nodes (planets), answer queries to check if two nodes are connected.
      </div>
      <div id="exp19" class="explanation">
        <strong>Solution Explanation:</strong> We store connections in an adjacency matrix and use a simple DFS to see if one node can reach another.
      </div>
      <pre><code>
// Check if two nodes are connected using a basic DFS on a matrix
#include <iostream>
using namespace std;
int n;
int adj[101][101];
bool visited[101];
void dfs(int node){
  visited[node] = true;
  for(int i = 0; i < n; i++){
    if(adj[node][i] == 1 && !visited[i])
      dfs(i);
  }
}
int main(){
  int m;
  cin >> n >> m;
  for(int i = 0; i < n; i++)
    for(int j = 0; j < n; j++)
      adj[i][j] = 0;
  for(int i = 0; i < m; i++){
    int u, v;
    cin >> u >> v;
    adj[u][v] = 1;
    adj[v][u] = 1;
  }
  int q;
  cin >> q;
  while(q--){
    int u, v;
    cin >> u >> v;
    for(int i = 0; i < n; i++) visited[i] = false;
    dfs(u);
    cout << (visited[v] ? "Yes" : "No") << "\n";
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Removing Digits -->
    <div id="removing-digits" class="snippet-container">
      <div class="snippet-header">
        <h2>Removing Digits</h2>
        <button class="explain-button" onclick="toggleExplanation('exp20')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a number, reduce it to 0 by subtracting one of its digits at a time; find the minimum number of steps.
      </div>
      <div id="exp20" class="explanation">
        <strong>Solution Explanation:</strong> We use recursion to try subtracting each nonzero digit until the number reaches 0, and we pick the fewest steps.
      </div>
      <pre><code>
// Remove one digit at a time until the number is 0
#include <iostream>
#include <climits>
using namespace std;
int solve(int n){
  if(n == 0) return 0;
  int best = INT_MAX;
  int temp = n;
  while(temp > 0){
    int d = temp % 10;
    temp /= 10;
    if(d > 0){
      int steps = 1 + solve(n - d);
      if(steps < best)
        best = steps;
    }
  }
  return best;
}
int main(){
  int n;
  cin >> n;
  cout << solve(n);
  return 0;
}
</code></pre>
    </div>

    <!-- Knight's Tour -->
    <div id="knights-tour" class="snippet-container">
      <div class="snippet-header">
        <h2>Knight's Tour</h2>
        <button class="explain-button" onclick="toggleExplanation('exp21')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Find a sequence of moves for a knight on an 8×8 chessboard such that it visits every square exactly once.
      </div>
      <div id="exp21" class="explanation">
        <strong>Solution Explanation:</strong> We use a very basic backtracking method to try every possible knight move until we fill the board.
      </div>
      <pre><code>
// Try every move for a knight on an 8x8 board until every square is visited
#include <iostream>
using namespace std;
int board[8][8];
int dx[8] = {2,1,-1,-2,-2,-1,1,2};
int dy[8] = {1,2,2,1,-1,-2,-2,-1};
bool isValid(int x, int y){
  return (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] == -1);
}
bool solveTour(int x, int y, int move){
  if(move == 64) return true;
  for(int i = 0; i < 8; i++){
    int nextX = x + dx[i];
    int nextY = y + dy[i];
    if(isValid(nextX, nextY)){
      board[nextX][nextY] = move;
      if(solveTour(nextX, nextY, move + 1))
        return true;
      board[nextX][nextY] = -1;
    }
  }
  return false;
}
int main(){
  for(int i = 0; i < 8; i++)
    for(int j = 0; j < 8; j++)
      board[i][j] = -1;
  board[0][0] = 0;
  if(solveTour(0,0,1)){
    for(int i = 0; i < 8; i++){
      for(int j = 0; j < 8; j++){
        cout << board[i][j] << "\t";
      }
      cout << "\n";
    }
  } else {
    cout << "No solution";
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Labyrinth -->
    <div id="labyrinth" class="snippet-container">
      <div class="snippet-header">
        <h2>Labyrinth</h2>
        <button class="explain-button" onclick="toggleExplanation('exp22')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a maze (grid) with walls (#), a starting point (S), and an exit (E), determine if there is a path from S to E.
      </div>
      <div id="exp22" class="explanation">
        <strong>Solution Explanation:</strong> We use a simple DFS to search from the starting cell for the exit, avoiding walls.
      </div>
      <pre><code>
// Use simple DFS to find an exit in a maze
#include <iostream>
using namespace std;
int n, m;
char maze[101][101];
bool visited[101][101];
bool findExit(int x, int y){
  if(x < 0 || x >= n || y < 0 || y >= m) return false;
  if(maze[x][y] == '#' || visited[x][y]) return false;
  if(maze[x][y] == 'E') return true;
  visited[x][y] = true;
  if(findExit(x+1,y) || findExit(x-1,y) || findExit(x,y+1) || findExit(x,y-1))
    return true;
  return false;
}
int main(){
  cin >> n >> m;
  for(int i = 0; i < n; i++){
    cin >> maze[i];
  }
  int startX, startY;
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      if(maze[i][j] == 'S'){
        startX = i;
        startY = j;
      }
    }
  }
  cout << (findExit(startX, startY) ? "Path found" : "No path");
  return 0;
}
</code></pre>
    </div>
  </div>
  <script>
    function toggleExplanation(id) {
      const elem = document.getElementById(id);
      const isHidden = elem.style.display === "none" || elem.style.display === "";
      elem.style.display = isHidden ? "block" : "none";
      const button = event.target;
      button.textContent = isHidden ? "Hide Explanation" : "Show Explanation";
    }
  </script>
</body>
</html>
