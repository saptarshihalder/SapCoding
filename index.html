<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Really Simple Algorithm Solutions</title>
  <style>
    :root {
      --primary: #3b82f6;
      --primary-dark: #2563eb;
      --secondary: #64748b;
      --border: #e2e8f0;
      --background: #f8fafc;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      line-height: 1.6;
      background: var(--background);
      color: #1e293b;
      padding-bottom: 3rem;
    }
    .header {
      background: white;
      padding: 2rem;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }
    .header h1 {
      margin: 0;
      color: var(--primary-dark);
      font-size: 2rem;
    }
    .header p {
      color: var(--secondary);
      margin: 0.5rem 0 0;
    }
    .container {
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    .snippet-container {
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
      overflow: hidden;
    }
    .snippet-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .snippet-header h2 {
      margin: 0;
      color: var(--primary-dark);
      font-size: 1.25rem;
    }
    .explain-button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }
    .explain-button:hover {
      background: var(--primary-dark);
    }
    .problem-statement {
      padding: 1rem;
      background: #fff9e6;
      border-bottom: 1px solid var(--border);
      color: var(--primary-dark);
      font-size: 1rem;
    }
    .explanation {
      display: none;
      padding: 1rem;
      background: #f0f7ff;
      border-bottom: 1px solid var(--border);
      color: var(--secondary);
      font-size: 0.95rem;
    }
    pre {
      margin: 0;
      padding: 1.5rem;
      background: #1e293b;
      color: #e2e8f0;
      overflow-x: auto;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    code {
      white-space: pre;
    }
    .problem-nav {
      position: fixed;
      top: 0;
      right: 0;
      background: white;
      padding: 1rem;
      border-left: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      border-bottom-left-radius: 0.5rem;
      max-height: 100vh;
      overflow-y: auto;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
    }
    .problem-nav h3 {
      margin: 0 0 1rem 0;
      color: var(--primary-dark);
    }
    .problem-nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .problem-nav li {
      margin-bottom: 0.5rem;
    }
    .problem-nav a {
      color: var(--secondary);
      text-decoration: none;
      font-size: 0.9rem;
    }
    .problem-nav a:hover {
      color: var(--primary);
    }
    @media (max-width: 768px) {
      .problem-nav {
        display: none;
      }
      .header h1 {
        font-size: 1.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Simple Algorithm Solutions</h1>
    <p>When Logic and Mind Breaks, Bruteforce Awakes.</p>
  </div>
  <nav class="problem-nav">
    <h3>Problems</h3>
    <ul>
      <li><a href="#fibonacci">Fibonacci</a></li>
      <li><a href="#missing-number">Missing Number</a></li>
      <li><a href="#repetitions">Repetitions</a></li>
      <li><a href="#subsequence">Is Subsequence</a></li>
      <li><a href="#increasing-array">Increasing Array</a></li>
      <li><a href="#sum-two">Sum of Two Values</a></li>
      <li><a href="#permutations">Permutations</a></li>
      <li><a href="#two-knights">Two Knights</a></li>
      <li><a href="#max-subarray">Max Subarray Sum</a></li>
      <li><a href="#knapsack">Fractional Knapsack</a></li>
      <li><a href="#counting-rooms">Counting Rooms</a></li>
      <li><a href="#josephus">Josephus Problem</a></li>
      <li><a href="#tasks">Tasks and Deadlines</a></li>
      <li><a href="#restaurant">Restaurant Customers</a></li>
      <li><a href="#increasing-subseq">Increasing Subsequence</a></li>
      <li><a href="#min-coins">Minimizing Coins</a></li>
      <li><a href="#jump-game">Jump Game II</a></li>
      <li><a href="#grid-paths">Grid Paths</a></li>
      <li><a href="#planets">Planets Queries</a></li>
      <li><a href="#removing-digits">Removing Digits</a></li>
      <li><a href="#knights-tour">Knight's Tour</a></li>
      <li><a href="#labyrinth">Labyrinth</a></li>
    </ul>
  </nav>
  <div class="container">
    <!-- Fibonacci (unchanged) -->
    <div id="fibonacci" class="snippet-container">
      <div class="snippet-header">
        <h2>Compute Fibonacci</h2>
        <button class="explain-button" onclick="toggleExplanation('exp1')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a number n, compute the nth Fibonacci number (sequence: 0, 1, 1, 2, 3, …).
      </div>
      <div id="exp1" class="explanation">
        <strong>Solution Explanation:</strong> Use a simple loop starting with 0 and 1. Repeatedly add the two previous numbers to produce the next.
      </div>
      <pre><code>// Very simple Fibonacci: add two numbers repeatedly
#include <iostream>
using namespace std;
int main() {
  int n;
  cin >> n;
  if(n == 0) { cout << 0; return 0; }
  int a = 0, b = 1;
  for(int i = 2; i <= n; i++){
    int c = a + b;
    a = b;
    b = c;
  }
  cout << b;
  return 0;
}
</code></pre>
    </div>

    <!-- Missing Number (unchanged) -->
    <div id="missing-number" class="snippet-container">
      <div class="snippet-header">
        <h2>Missing Number</h2>
        <button class="explain-button" onclick="toggleExplanation('exp2')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given n and a list of n-1 numbers (from 1 to n), find the missing number.
      </div>
      <div id="exp2" class="explanation">
        <strong>Solution Explanation:</strong> For each number from 1 to n, scan the list to see which one isn’t there.
      </div>
      <pre><code>// Check every number 1 to n to find the missing one
#include <iostream>
using namespace std;
int main() {
  int n;
  cin >> n;
  int arr[1000];
  for (int i = 0; i < n - 1; i++){
    cin >> arr[i];
  }
  for (int num = 1; num <= n; num++){
    bool found = false;
    for (int i = 0; i < n - 1; i++){
      if(arr[i] == num){
        found = true;
        break;
      }
    }
    if(!found) { cout << num; break; }
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Repetitions (unchanged) -->
    <div id="repetitions" class="snippet-container">
      <div class="snippet-header">
        <h2>Repetitions</h2>
        <button class="explain-button" onclick="toggleExplanation('exp3')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a sentence, print out any letter that appears more than once.
      </div>
      <div id="exp3" class="explanation">
        <strong>Solution Explanation:</strong> For each letter, use nested loops to count its occurrences.
      </div>
      <pre><code>
// For each letter, count how many times it shows up
#include <iostream>
#include <cstring>
using namespace std;
int main() {
  char text[1000];
  cin.getline(text, 1000);
  int len = strlen(text);
  for (int i = 0; i < len; i++){
    bool alreadySeen = false;
    for (int j = 0; j < i; j++){
      if(text[j] == text[i]) { alreadySeen = true; break; }
    }
    if(alreadySeen) continue;
    int count = 0;
    for (int k = 0; k < len; k++){
      if(text[i] == text[k]) count++;
    }
    if(count > 1) cout << text[i] << " ";
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Is Subsequence (unchanged) -->
    <div id="subsequence" class="snippet-container">
      <div class="snippet-header">
        <h2>Is Subsequence</h2>
        <button class="explain-button" onclick="toggleExplanation('exp4')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given two strings, check whether the second appears in the first in the same order.
      </div>
      <div id="exp4" class="explanation">
        <strong>Solution Explanation:</strong> Traverse the first string and try to match each letter of the second string in order.
      </div>
      <pre><code>
// Check if every letter of t appears in s in order
#include <iostream>
#include <cstring>
using namespace std;
int main() {
  char s[1000], t[1000];
  cin.getline(s, 1000);
  cin.getline(t, 1000);
  int i = 0, j = 0;
  while(s[i] != '\0' && t[j] != '\0'){
    if(s[i] == t[j]) j++;
    i++;
  }
  cout << (t[j]=='\0' ? "Yes" : "No");
  return 0;
}
</code></pre>
    </div>

    <!-- Increasing Array (unchanged) -->
    <div id="increasing-array" class="snippet-container">
      <div class="snippet-header">
        <h2>Increasing Array</h2>
        <button class="explain-button" onclick="toggleExplanation('exp5')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array, increase numbers where needed so that the array becomes non-decreasing. Report the total increments.
      </div>
      <div id="exp5" class="explanation">
        <strong>Solution Explanation:</strong> For each element, if it is less than the previous one, add the difference to make it equal.
      </div>
      <pre><code>
// Increase numbers to make the array non-decreasing
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  int moves = 0;
  for(int i = 1; i < n; i++){
    if(arr[i] < arr[i-1]){
      moves += arr[i-1] - arr[i];
      arr[i] = arr[i-1];
    }
  }
  cout << moves;
  return 0;
}
</code></pre>
    </div>

    <!-- Sum of Two Values (unchanged) -->
    <div id="sum-two" class="snippet-container">
      <div class="snippet-header">
        <h2>Sum of Two Values</h2>
        <button class="explain-button" onclick="toggleExplanation('exp6')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a list and a target sum, find two numbers that add up to that target.
      </div>
      <div id="exp6" class="explanation">
        <strong>Solution Explanation:</strong> Try every pair in the list until you find one whose sum matches the target.
      </div>
      <pre><code>
// Check every pair to see if they add up to target
#include <iostream>
using namespace std;
int main(){
  int n, target;
  cin >> n >> target;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  for(int i = 0; i < n; i++){
    for(int j = i+1; j < n; j++){
      if(arr[i] + arr[j] == target){
        cout << i << " " << j;
        return 0;
      }
    }
  }
  cout << "No solution";
  return 0;
}
</code></pre>
    </div>

    <!-- Permutations (unchanged) -->
    <div id="permutations" class="snippet-container">
      <div class="snippet-header">
        <h2>Permutations</h2>
        <button class="explain-button" onclick="toggleExplanation('exp7')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a word, list every possible arrangement of its letters.
      </div>
      <div id="exp7" class="explanation">
        <strong>Solution Explanation:</strong> Use simple recursion with swapping to generate every ordering.
      </div>
      <pre><code>
// Print every rearrangement of a word (brute force)
#include <iostream>
#include <cstring>
using namespace std;
void swap(char &a, char &b){
  char temp = a;
  a = b;
  b = temp;
}
void permute(char s[], int l, int r){
  if(l == r)
    cout << s << "\n";
  else {
    for(int i = l; i <= r; i++){
      swap(s[l], s[i]);
      permute(s, l+1, r);
      swap(s[l], s[i]); // backtrack
    }
  }
}
int main(){
  char s[1000];
  cin >> s;
  int n = strlen(s);
  permute(s, 0, n-1);
  return 0;
}
</code></pre>
    </div>

    <!-- Two Knights (unchanged) -->
    <div id="two-knights" class="snippet-container">
      <div class="snippet-header">
        <h2>Two Knights</h2>
        <button class="explain-button" onclick="toggleExplanation('exp8')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> On an n×n chessboard, count how many ways two knights can be placed without threatening each other.
      </div>
      <div id="exp8" class="explanation">
        <strong>Solution Explanation:</strong> Check every pair of board positions. If the knights do not attack each other, count the pair.
      </div>
      <pre><code>
// Count placements for two knights on an n x n board (brute force)
#include <iostream>
#include <cstdlib>
using namespace std;
bool attacks(int x1, int y1, int x2, int y2){
  int dx = abs(x1 - x2), dy = abs(y1 - y2);
  return (dx == 1 && dy == 2) || (dx == 2 && dy == 1);
}
int main(){
  int n;
  cin >> n;
  long long count = 0;
  for(int x1 = 0; x1 < n; x1++){
    for(int y1 = 0; y1 < n; y1++){
      for(int x2 = 0; x2 < n; x2++){
        for(int y2 = 0; y2 < n; y2++){
          if(x1==x2 && y1==y2) continue;
          if(!attacks(x1,y1,x2,y2))
            count++;
        }
      }
    }
  }
  cout << count/2;
  return 0;
}
</code></pre>
    </div>

    <!-- Maximum Subarray Sum (unchanged) -->
    <div id="max-subarray" class="snippet-container">
      <div class="snippet-header">
        <h2>Maximum Subarray Sum</h2>
        <button class="explain-button" onclick="toggleExplanation('exp9')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Find the maximum sum obtainable from a contiguous subarray.
      </div>
      <div id="exp9" class="explanation">
        <strong>Solution Explanation:</strong> Use three nested loops to check every possible subarray and keep track of the largest sum.
      </div>
      <pre><code>
// Try all subarrays and remember the biggest sum
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  int maxSum = arr[0];
  for(int i = 0; i < n; i++){
    for(int j = i; j < n; j++){
      int sum = 0;
      for(int k = i; k <= j; k++){
        sum += arr[k];
      }
      if(sum > maxSum)
        maxSum = sum;
    }
  }
  cout << maxSum;
  return 0;
}
</code></pre>
    </div>

    <!-- Fractional Knapsack (unchanged) -->
    <div id="knapsack" class="snippet-container">
      <div class="snippet-header">
        <h2>Fractional Knapsack</h2>
        <button class="explain-button" onclick="toggleExplanation('exp10')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given items with weights and values and a bag with limited capacity, choose fractions of items to maximize total value.
      </div>
      <div id="exp10" class="explanation">
        <strong>Solution Explanation:</strong> Try fixed fractions (0, 0.1, …, 1) for each item recursively and update the best total value.
      </div>
      <pre><code>
// Try fractions of each item (using a fixed step) to get best value
#include <iostream>
using namespace std;
double best = 0;
void tryItems(int index, double weight, double value, double capacity, int n, double w[], double v[], double step){
  if(index == n){
    if(weight <= capacity && value > best)
      best = value;
    return;
  }
  for(double frac = 0; frac <= 1.0; frac += step){
    double newWeight = weight + frac * w[index];
    double newValue = value + frac * v[index];
    if(newWeight <= capacity)
      tryItems(index+1, newWeight, newValue, capacity, n, w, v, step);
  }
}
int main(){
  int n;
  double capacity;
  cin >> n >> capacity;
  double w[1000], v[1000];
  for(int i = 0; i < n; i++){
    cin >> w[i] >> v[i];
  }
  double step = 0.1;
  tryItems(0, 0.0, 0.0, capacity, n, w, v, step);
  cout << best;
  return 0;
}
</code></pre>
    </div>

    <!-- Counting Rooms (Brute Force Iterative Flood Fill) -->
    <div id="counting-rooms" class="snippet-container">
      <div class="snippet-header">
        <h2>Counting Rooms</h2>
        <button class="explain-button" onclick="toggleExplanation('exp11')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a grid (with '.' as open space and '#' as walls), count the number of connected open areas ("rooms").
      </div>
      <div id="exp11" class="explanation">
        <strong>Solution Explanation:</strong> Instead of using DFS, we repeatedly scan the grid. For each unvisited open cell, we mark it and then, via repeated full‐grid scans, mark all its neighbors. Each complete marking counts as one room.
      </div>
      <pre><code>
// Brute-force iterative flood fill (no DFS) to count rooms
#include <iostream>
using namespace std;
int main(){
  int n, m;
  cin >> n >> m;
  char grid[101][101];
  for (int i = 0; i < n; i++){
    cin >> grid[i];
  }
  int rooms = 0;
  while (true) {
    int start_i = -1, start_j = -1;
    // Find an unvisited open cell ('.')
    for (int i = 0; i < n; i++){
      for (int j = 0; j < m; j++){
        if (grid[i][j] == '.'){
          start_i = i; start_j = j;
          break;
        }
      }
      if(start_i != -1) break;
    }
    if(start_i == -1) break; // No more rooms
    // Mark this room iteratively
    grid[start_i][start_j] = '*';
    bool changed = true;
    while(changed){
      changed = false;
      for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
          if(grid[i][j] == '.'){
            if((i > 0 && grid[i-1][j]=='*') ||
               (i < n-1 && grid[i+1][j]=='*') ||
               (j > 0 && grid[i][j-1]=='*') ||
               (j < m-1 && grid[i][j+1]=='*')){
              grid[i][j] = '*';
              changed = true;
            }
          }
        }
      }
    }
    rooms++;
  }
  cout << rooms;
  return 0;
}
</code></pre>
    </div>

    <!-- Josephus Problem (unchanged) -->
    <div id="josephus" class="snippet-container">
      <div class="snippet-header">
        <h2>Josephus Problem</h2>
        <button class="explain-button" onclick="toggleExplanation('exp12')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> In a circle of n people, remove every kth person until only one remains.
      </div>
      <div id="exp12" class="explanation">
        <strong>Solution Explanation:</strong> Simulate the removal by shifting elements in an array until one person remains.
      </div>
      <pre><code>
// Remove every kth person until one remains
#include <iostream>
using namespace std;
int main(){
  int n, k;
  cin >> n >> k;
  int circle[1000];
  for(int i = 0; i < n; i++){
    circle[i] = i + 1;
  }
  int size = n, index = 0;
  while(size > 1){
    index = (index + k - 1) % size;
    for(int i = index; i < size - 1; i++){
      circle[i] = circle[i+1];
    }
    size--;
  }
  cout << circle[0];
  return 0;
}
</code></pre>
    </div>

    <!-- Tasks and Deadlines (unchanged) -->
    <div id="tasks" class="snippet-container">
      <div class="snippet-header">
        <h2>Tasks and Deadlines</h2>
        <button class="explain-button" onclick="toggleExplanation('exp13')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given tasks with deadlines and profits, determine the order that maximizes profit.
      </div>
      <div id="exp13" class="explanation">
        <strong>Solution Explanation:</strong> Try every permutation of tasks by swapping them recursively and calculate the profit.
      </div>
      <pre><code>
// Try every order (permutation) of tasks to get maximum profit
#include <iostream>
using namespace std;
int n, bestProfit = 0;
int d[10], p[10];
void swap(int &a, int &b){
  int temp = a; a = b; b = temp;
}
void permute(int pos){
  if(pos == n){
    int time = 0, profit = 0;
    for(int i = 0; i < n; i++){
      time++;
      if(time <= d[i])
        profit += p[i];
    }
    if(profit > bestProfit)
      bestProfit = profit;
    return;
  }
  for(int i = pos; i < n; i++){
    swap(d[pos], d[i]);
    swap(p[pos], p[i]);
    permute(pos+1);
    swap(d[pos], d[i]);
    swap(p[pos], p[i]);
  }
}
int main(){
  cin >> n;
  for(int i = 0; i < n; i++){
    cin >> d[i] >> p[i];
  }
  permute(0);
  cout << bestProfit;
  return 0;
}
</code></pre>
    </div>

    <!-- Restaurant Customers (unchanged) -->
    <div id="restaurant" class="snippet-container">
      <div class="snippet-header">
        <h2>Restaurant Customers</h2>
        <button class="explain-button" onclick="toggleExplanation('exp14')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given arrival and departure times for customers, determine the maximum number present at any time.
      </div>
      <div id="exp14" class="explanation">
        <strong>Solution Explanation:</strong> Scan every time unit between the earliest arrival and latest departure to count customers.
      </div>
      <pre><code>
// Count customers at each time unit to find the maximum number present
#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  int start[1000], finish[1000];
  int minT = 1000000000, maxT = 0;
  for(int i = 0; i < n; i++){
    cin >> start[i] >> finish[i];
    if(start[i] < minT) minT = start[i];
    if(finish[i] > maxT) maxT = finish[i];
  }
  int maxCust = 0;
  for(int t = minT; t <= maxT; t++){
    int count = 0;
    for(int i = 0; i < n; i++){
      if(t >= start[i] && t <= finish[i])
        count++;
    }
    if(count > maxCust)
      maxCust = count;
  }
  cout << maxCust;
  return 0;
}
</code></pre>
    </div>

    <!-- Increasing Subsequence (unchanged) -->
    <div id="increasing-subseq" class="snippet-container">
      <div class="snippet-header">
        <h2>Increasing Subsequence</h2>
        <button class="explain-button" onclick="toggleExplanation('exp15')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array, find the length of the longest subsequence with strictly increasing numbers.
      </div>
      <div id="exp15" class="explanation">
        <strong>Solution Explanation:</strong> Use recursion (by choosing to include or skip each number) to determine the longest increasing sequence.
      </div>
      <pre><code>
// Try all ways to pick numbers so they are in increasing order
#include <iostream>
using namespace std;
int best = 0;
void dfs(int i, int last, int count, int n, int arr[]){
  if(i == n){
    if(count > best) best = count;
    return;
  }
  // Skip this number
  dfs(i+1, last, count, n, arr);
  // Include this number if it is larger than the last chosen
  if(arr[i] > last)
    dfs(i+1, arr[i], count+1, n, arr);
}
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  dfs(0, -1000000000, 0, n, arr);
  cout << best;
  return 0;
}
</code></pre>
    </div>

    <!-- Minimizing Coins (unchanged) -->
    <div id="min-coins" class="snippet-container">
      <div class="snippet-header">
        <h2>Minimizing Coins</h2>
        <button class="explain-button" onclick="toggleExplanation('exp16')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given coin denominations and a target amount, find the minimum number of coins needed.
      </div>
      <div id="exp16" class="explanation">
        <strong>Solution Explanation:</strong> Recursively try all combinations of coins (brute force) to determine the fewest required.
      </div>
      <pre><code>
// Try all coin combinations (very brute force)
#include <iostream>
#include <climits>
using namespace std;
int bestCoins = INT_MAX;
void tryCoins(int index, int count, int remaining, int n, int coins[]){
  if(remaining == 0){
    if(count < bestCoins)
      bestCoins = count;
    return;
  }
  if(index >= n) return;
  for(int i = 0; i * coins[index] <= remaining; i++){
    tryCoins(index+1, count+i, remaining - i * coins[index], n, coins);
  }
}
int main(){
  int n, amount;
  cin >> n >> amount;
  int coins[1000];
  for(int i = 0; i < n; i++){
    cin >> coins[i];
  }
  tryCoins(0, 0, amount, n, coins);
  cout << (bestCoins == INT_MAX ? -1 : bestCoins);
  return 0;
}
</code></pre>
    </div>

    <!-- Jump Game II (unchanged) -->
    <div id="jump-game" class="snippet-container">
      <div class="snippet-header">
        <h2>Jump Game II</h2>
        <button class="explain-button" onclick="toggleExplanation('exp17')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given an array where each element is the maximum jump length from that position, find the minimum number of jumps needed to reach the end.
      </div>
      <div id="exp17" class="explanation">
        <strong>Solution Explanation:</strong> Recursively try every jump option from each position and track the minimum number needed.
      </div>
      <pre><code>
// Try every jump (brute force) to reach the end of the array
#include <iostream>
#include <climits>
using namespace std;
int minJumps = INT_MAX;
void jump(int index, int count, int n, int arr[]){
  if(index >= n - 1){
    if(count < minJumps)
      minJumps = count;
    return;
  }
  for(int j = 1; j <= arr[index]; j++){
    jump(index+j, count+1, n, arr);
  }
}
int main(){
  int n;
  cin >> n;
  int arr[1000];
  for(int i = 0; i < n; i++){
    cin >> arr[i];
  }
  jump(0, 0, n, arr);
  cout << (minJumps == INT_MAX ? -1 : minJumps);
  return 0;
}
</code></pre>
    </div>

    <!-- Grid Paths (unchanged) -->
    <div id="grid-paths" class="snippet-container">
      <div class="snippet-header">
        <h2>Grid Paths</h2>
        <button class="explain-button" onclick="toggleExplanation('exp18')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Count the number of ways to move from the top left to the bottom right of a grid if you can only move right or down.
      </div>
      <div id="exp18" class="explanation">
        <strong>Solution Explanation:</strong> Use a simple recursive function to sum the number of paths moving right and down.
      </div>
      <pre><code>
// Count paths in a grid (only right and down moves)
#include <iostream>
using namespace std;
int countPaths(int i, int j, int rows, int cols){
  if(i == rows - 1 && j == cols - 1)
    return 1;
  if(i >= rows || j >= cols)
    return 0;
  return countPaths(i+1, j, rows, cols) + countPaths(i, j+1, rows, cols);
}
int main(){
  int rows, cols;
  cin >> rows >> cols;
  cout << countPaths(0, 0, rows, cols);
  return 0;
}
</code></pre>
    </div>

    <!-- Planets Queries (Brute Force Iterative Transitive Closure) -->
    <div id="planets" class="snippet-container">
      <div class="snippet-header">
        <h2>Planets Queries</h2>
        <button class="explain-button" onclick="toggleExplanation('exp19')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a set of connections between nodes (planets), answer queries about whether two nodes are connected.
      </div>
      <div id="exp19" class="explanation">
        <strong>Solution Explanation:</strong> Instead of DFS, we use iterative relaxation. We repeatedly scan all nodes; if a node is reachable and it connects to another, we mark that other as reachable.
      </div>
      <pre><code>
// Check connectivity using iterative relaxation (no DFS/BFS)
#include <iostream>
using namespace std;
int main(){
  int n, m;
  cin >> n >> m;
  int adj[101][101];
  for (int i = 0; i < n; i++){
    for (int j = 0; j < n; j++){
      adj[i][j] = 0;
    }
  }
  for (int i = 0; i < m; i++){
    int u, v;
    cin >> u >> v;
    adj[u][v] = 1;
    adj[v][u] = 1;
  }
  int q;
  cin >> q;
  while(q--){
    int u, v;
    cin >> u >> v;
    bool reachable[101] = {false};
    reachable[u] = true;
    bool changed = true;
    while(changed){
      changed = false;
      for (int i = 0; i < n; i++){
        if(reachable[i]){
          for (int j = 0; j < n; j++){
            if(adj[i][j]==1 && !reachable[j]){
              reachable[j] = true;
              changed = true;
            }
          }
        }
      }
    }
    cout << (reachable[v] ? "Yes" : "No") << "\n";
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Removing Digits (unchanged) -->
    <div id="removing-digits" class="snippet-container">
      <div class="snippet-header">
        <h2>Removing Digits</h2>
        <button class="explain-button" onclick="toggleExplanation('exp20')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Reduce a number to 0 by subtracting one of its digits at a time. Find the minimum number of steps.
      </div>
      <div id="exp20" class="explanation">
        <strong>Solution Explanation:</strong> Use recursion to try subtracting each nonzero digit and choose the option that reaches 0 in the fewest steps.
      </div>
      <pre><code>
// Remove one digit at a time until the number is 0
#include <iostream>
#include <climits>
using namespace std;
int solve(int n){
  if(n == 0) return 0;
  int best = INT_MAX;
  int temp = n;
  while(temp > 0){
    int d = temp % 10;
    temp /= 10;
    if(d > 0){
      int steps = 1 + solve(n - d);
      if(steps < best)
        best = steps;
    }
  }
  return best;
}
int main(){
  int n;
  cin >> n;
  cout << solve(n);
  return 0;
}
</code></pre>
    </div>

    <!-- Knight's Tour (unchanged) -->
    <div id="knights-tour" class="snippet-container">
      <div class="snippet-header">
        <h2>Knight's Tour</h2>
        <button class="explain-button" onclick="toggleExplanation('exp21')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Find a sequence of knight moves on an 8×8 chessboard so that every square is visited exactly once.
      </div>
      <div id="exp21" class="explanation">
        <strong>Solution Explanation:</strong> Use simple backtracking (via recursion) to try every knight move until the board is completely filled.
      </div>
      <pre><code>
// Try every move for a knight on an 8x8 board until every square is visited
#include <iostream>
using namespace std;
int board[8][8];
int dx[8] = {2,1,-1,-2,-2,-1,1,2};
int dy[8] = {1,2,2,1,-1,-2,-2,-1};
bool isValid(int x, int y){
  return (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] == -1);
}
bool solveTour(int x, int y, int move){
  if(move == 64) return true;
  for(int i = 0; i < 8; i++){
    int nextX = x + dx[i];
    int nextY = y + dy[i];
    if(isValid(nextX, nextY)){
      board[nextX][nextY] = move;
      if(solveTour(nextX, nextY, move + 1))
        return true;
      board[nextX][nextY] = -1;
    }
  }
  return false;
}
int main(){
  for(int i = 0; i < 8; i++)
    for(int j = 0; j < 8; j++)
      board[i][j] = -1;
  board[0][0] = 0;
  if(solveTour(0,0,1)){
    for(int i = 0; i < 8; i++){
      for(int j = 0; j < 8; j++){
        cout << board[i][j] << "\t";
      }
      cout << "\n";
    }
  } else {
    cout << "No solution";
  }
  return 0;
}
</code></pre>
    </div>

    <!-- Labyrinth (Brute-Force Iterative Flood Fill) -->
    <div id="labyrinth" class="snippet-container">
      <div class="snippet-header">
        <h2>Labyrinth</h2>
        <button class="explain-button" onclick="toggleExplanation('exp22')">Show Explanation</button>
      </div>
      <div class="problem-statement">
        <strong>Problem:</strong> Given a maze with walls (#), a starting point (S), and an exit (E), determine if there is a path from S to E.
      </div>
      <div id="exp22" class="explanation">
        <strong>Solution Explanation:</strong> Instead of DFS, we use a brute-force iterative approach. We mark the starting cell as reachable, then repeatedly scan the entire maze to mark any cell that is adjacent to a reachable cell (and not a wall). Finally, we check if the exit is marked as reachable.
      </div>
      <pre><code>
// Brute-force iterative search to find an exit in a maze
#include <iostream>
using namespace std;
int main(){
  int n, m;
  cin >> n >> m;
  char maze[101][101];
  for(int i = 0; i < n; i++){
    cin >> maze[i];
  }
  int startX, startY;
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      if(maze[i][j] == 'S'){
        startX = i;
        startY = j;
      }
    }
  }
  // Create a boolean grid for reachable cells
  bool reachable[101][101] = {false};
  reachable[startX][startY] = true;
  bool changed = true;
  while(changed){
    changed = false;
    for(int i = 0; i < n; i++){
      for(int j = 0; j < m; j++){
        if(!reachable[i][j] && maze[i][j] != '#'){
          if((i > 0 && reachable[i-1][j]) ||
             (i < n-1 && reachable[i+1][j]) ||
             (j > 0 && reachable[i][j-1]) ||
             (j < m-1 && reachable[i][j+1])){
            reachable[i][j] = true;
            changed = true;
          }
        }
      }
    }
  }
  bool found = false;
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      if(maze[i][j]=='E' && reachable[i][j]){
        found = true;
        break;
      }
    }
    if(found) break;
  }
  cout << (found ? "Path found" : "No path");
  return 0;
}
</code></pre>
    </div>
  </div>
  <script>
    function toggleExplanation(id) {
      const elem = document.getElementById(id);
      const isHidden = elem.style.display === "none" || elem.style.display === "";
      elem.style.display = isHidden ? "block" : "none";
      const button = event.target;
      button.textContent = isHidden ? "Hide Explanation" : "Show Explanation";
    }
  </script>
</body>
</html>
